# import librariesimport osimport pandas as pdimport numpy as npimport datetime as dt# must match a reference ontologyconcept = pd.read_csv('/opt/data/dim/CONCEPT.csv.gz',                      header=0, sep='\t', low_memory=False)concept = concept[['concept_code', 'concept_id']]concept.drop_duplicates(inplace=True)concept.rename(columns= {'concept_code': 'cpt'}, inplace=True)# make a control file to iterate throughpath = '/opt/data/raw/'files = os.listdir(path)csv_files = [x for x in files if x.endswith(".json.gz")]# removes '.json.gz' (8 characters)hospital_ids = [int(x[:-8]) for x in csv_files] control = pd.DataFrame({'file': csv_files, 'hospital_id': hospital_ids})#cross reference the control file with the static dimension tabledim = pd.read_csv('/opt/data/dim/hospital.csv',                  usecols=['hospital_id', 'affiliation'])control = control.merge(dim, how= 'left', on='hospital_id')control.sort_values(by='hospital_id', inplace=True, ignore_index=True)for i in range(control.shape[0]):      out = None        # print file you are working on now    print(dt.datetime.now().strftime("%Y-%m-%d %H:%M:%S") +           ' - parsing hospital - ' + str(control.hospital_id[i]))        # hospital specific configuration    if control.hospital_id[i] in list(range(8,15)):        # read in the file        df = pd.read_json('/opt/data/raw/' + control.file[i], lines=True)        out = pd.DataFrame({            'cpt': df['CPT Code'],            'gross': df['Charge '],            'cash': df['Self Pay Median Charge '],            'max': df['Maximum Reimbursement '],            'min': df['Minimum Reimbursement ']            })        out.drop_duplicates(inplace=True)        elif control.hospital_id[i] in list(range(23,29)):        # read in the file        df = pd.read_json('/opt/data/raw/' + control.file[i], lines=True)                cpt_df = df.loc[df['code type'] == 'cpt']        out = pd.DataFrame({            'cpt': cpt_df['code'],            'gross': cpt_df['gross charge'],            'cash': cpt_df['discounted cash price'],            'max': cpt_df['de-identified maximum negotiated charge'],            'min': cpt_df['de-identified minimum negotiated charge']            })        out.drop_duplicates(inplace=True)        elif control.hospital_id[i] in [15, 37, 53, 56, 57, 64, 72]:        # read in the file        df = pd.read_json('/opt/data/raw/' + control.file[i],                          lines=True, encoding_errors='ignore')                cpt_df = df.loc[df['code type'] == 'cpt']        out = pd.DataFrame({            'cpt': cpt_df['code'],            'gross': cpt_df['gross charge'],            'cash': cpt_df['discounted cash price'],            'max': cpt_df['de-identified maximum negotiated charge'],            'min': cpt_df['de-identified minimum negotiated charge']            })        out.drop_duplicates(inplace=True)        elif control.hospital_id[i] in [44]:        # read in the file        df = pd.read_json('/opt/data/raw/' + control.file[i])                all_payer_df = df.loc[df['str_payer'] == 'All Payer All Plans']        out = pd.DataFrame({            'cpt': all_payer_df['keyStr_Associated_Codes'],            'gross': all_payer_df['num_Gross_Charge'],            'cash': all_payer_df['num_Cash_Discount_Price'],            'max': all_payer_df['num_DeIdentified_Max_Allowed'],            'min': all_payer_df['num_Deidentified_Min_Allowed']            })        out.drop_duplicates(inplace=True)        # take the first of the values provided        out['cpt'] = out.cpt.str.extract(r'(\d{5})')        # change 'N/A' to NaN        out.loc[out['gross'] == 'N/A', 'gross'] = np.nan        out.loc[out['cash'] == 'N/A', 'cash'] = np.nan        out.loc[out['max'] == 'N/A', 'max'] = np.nan        out.loc[out['min'] == 'N/A', 'min'] = np.nan        # convert to float        out['gross'] = out['gross'].astype(float)        out['cash'] = out['cash'].astype(float)        out['max'] = out['max'].astype(float)        out['min'] = out['min'].astype(float)             # Check if out was created in the previous step    if out is not None:        # uniform        out.dropna(subset=['cpt'], inplace=True)        out = out[out.cpt != '']        out = out[out.cpt != '*']                # must match a reference code, usually CPT or HCPCS        out = out.merge(concept, on='cpt', sort=True)        out = out.drop('cpt', axis=1)                # melt from wide to long, and clean        long = pd.melt(out, id_vars='concept_id')        if long.value.dtypes not in ('float64', 'int64'):            long['value'] = long['value'].str.replace('[,-]', '', regex=True)            long['value'] = long['value'].str.replace('[$]', '', regex=True)            long['value'] = long['value'].str.replace('[A-Za-z]', '', regex=True)            long['value'] = long['value'].str.strip()            # some values end up being an empty string            long.loc[long['value'] == '', 'value'] = np.nan             long['value'] = long.value.astype(float)        long.dropna(subset=['value'], inplace=True)        long = long[long.value > 0]        # Add hospital id and order columns        long['hospital_id'] = control.hospital_id[i]        long = long[long.columns[[3,0,1,2]]]                # write the data to a flatfile for postgres        if long.shape[0] > 0:            out_path = '/opt/data/transformed/' + str(control.hospital_id[i]) + '.csv'            long.to_csv(out_path, header=False, index=None)            # clear variables from last iteration        del out        del long